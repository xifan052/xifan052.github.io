"use strict";(self.webpackChunkxifan_blog=self.webpackChunkxifan_blog||[]).push([[3542],{8871:(e,a,c)=>{c.r(a),c.d(a,{comp:()=>l,data:()=>u});var t=c(641);const d=[(0,t.Fv)('<h1 id="" tabindex="-1"><a class="header-anchor" href="#"><span></span></a></h1><h2 id="vue-react" tabindex="-1"><a class="header-anchor" href="#vue-react"><span>Vue&amp;React</span></a></h2><h3 id="vue和react中key的作用" tabindex="-1"><a class="header-anchor" href="#vue和react中key的作用"><span>Vue和React中key的作用？</span></a></h3><p>作为一个唯一的标识，在diff时更快速的查找对应的节点，作为列表组件时，会增加性能消耗，针对节点变动，会提高查找效率</p><p>在Vue中，当使用v-for进行列表渲染时，每个列表项都会被赋予一个唯一的key值。Vue的diff算法会利用这个key值来追踪每个节点的身份，从而进行高效的更新。具体来说，当数据发生变化时，Vue会生成新的虚拟DOM树，并与旧的虚拟DOM树进行比较。在比较过程中，Vue会根据新旧虚拟DOM树中的key值来判断节点是否需要更新或重新创建。如果新旧虚拟DOM树中的某个节点具有相同的key值，但它们的属性或内容发生了变化，那么Vue会更新该节点的属性或内容，而不是重新创建整个节点。这种基于key值的比较方式使得Vue能够更精确地控制节点的更新，从而提高渲染性能。 而在React中，key同样被用于追踪节点的身份，并在数据变化时进行高效的更新。与Vue不同的是，React的diff算法在比较节点时，会同时考虑节点的类型和key值。如果新旧虚拟DOM树中的某个节点具有相同的类型和key值，但它们的属性或内容发生了变化，那么React会更新该节点的属性或内容。然而，如果节点的类型发生了变化（即使key值相同），React会认为这是两个不同的节点，并会删除旧的节点并创建新的节点。这种处理方式可能会导致一些不必要的节点创建和删除操作，从而降低渲染性能。</p><p>总的来说，Vue和React中的key在diff比较上的主要区别在于它们如何处理节点的类型和属性变化。Vue更倾向于保留和更新现有节点，而React在某些情况下可能会更倾向于创建新节点。这两种方式各有优缺点，具体选择哪种方式取决于应用程序的具体需求和性能要求。</p><h3 id="vue和react的区别" tabindex="-1"><a class="header-anchor" href="#vue和react的区别"><span>Vue和React的区别</span></a></h3><p>首先相同点是都维护一个虚拟dom，通过数据更新视图；不同点可以分为以下几条：</p><ol><li><p>框架设计 <code>Vue</code>基于数据劫持的方式实现双向绑定；<code>React</code>则采用了单向数据流的方式，当数据发生变化时，需要手动更新视图；</p></li><li><p>扩展 <code>Vue</code>是一个渐进式的<code>JavaScript</code>框架，官方提供了完整的生态来扩展功能，根据需求按需引入； <code>React</code>是一个库，自行选择组合来扩展功能；</p></li><li><p>编译 <code>Vue</code>在开发阶段将<code>template</code>编译为渲染函数，静态节点提升、模板预编译，减少运行时的性能消耗</p></li><li><p>性能 <code>Vue</code>通过模板编译和数据监听机制实现局部更新，只有依赖的部分发生变化时，组件才会重新渲染，减少了不必要的渲染；</p></li></ol><p>而 React 使用虚拟 DOM 进行全量更新，但具有更精确和灵活的变化计算能力</p><h3 id="vue和react在diff算法上的差异" tabindex="-1"><a class="header-anchor" href="#vue和react在diff算法上的差异"><span>Vue和React在diff算法上的差异</span></a></h3><p>首先都是忽略跨级比较，只做同级比较</p><ul><li><p><strong>1.列表比对方式</strong><code>Vue</code>采用从两端到中间的比对方式，当一个集合，只是把最后一个节点移动到了第一个，<code>Vue</code>只会把最后一个节点移动到第一个， <code>React</code>采用从左到右依次比对的方式，会把前面的节点依次移动， 总体上，vue的对比方式更高效；</p></li><li><p><strong>2.节点比对方式</strong><code>Vue</code>是比较节点类型和key，还有属性，当节点元素类型相同，但是<code>className</code>不同，认为是不同类型元素，删除重建， <code>React</code>只比较节点类型和key，同样的情况<code>React</code>会认为是同类型节点，只是修改节点属性</p></li></ul>',13)],i={},l=(0,c(6262).A)(i,[["render",function(e,a){return(0,t.uX)(),(0,t.CE)("div",null,d)}]]),u=JSON.parse('{"path":"/blogs/interview/Vue_React.html","title":"","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"Vue&React","slug":"vue-react","link":"#vue-react","children":[{"level":3,"title":"Vue和React中key的作用？","slug":"vue和react中key的作用","link":"#vue和react中key的作用","children":[]},{"level":3,"title":"Vue和React的区别","slug":"vue和react的区别","link":"#vue和react的区别","children":[]},{"level":3,"title":"Vue和React在diff算法上的差异","slug":"vue和react在diff算法上的差异","link":"#vue和react在diff算法上的差异","children":[]}]}],"git":{"createdTime":1737108179000,"updatedTime":1737108179000,"contributors":[{"name":"稀饭","email":"lixifan@ane56.com","commits":1}]},"filePathRelative":"blogs/interview/Vue&React.md"}')}}]);