"use strict";(self.webpackChunkxifan_blog=self.webpackChunkxifan_blog||[]).push([[4542],{3479:(e,n,s)=>{s.r(n),s.d(n,{comp:()=>c,data:()=>u});var a=s(641);const t=(0,a.Fv)('<h3 id="vue2-vue3生命周期区别" tabindex="-1"><a class="header-anchor" href="#vue2-vue3生命周期区别"><span>Vue2/Vue3生命周期区别</span></a></h3><ol><li>语法上用<code>on</code>作为前缀；</li><li>创建前后的钩子替换为了<code>setup</code>;</li><li>销毁前的钩子替换为了<code>onBeforeUnmount</code>;</li><li>销毁后的钩子替换为了<code>onUnmounted</code>;</li></ol><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>beforeCreate <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\ncreated <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token function">setup</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\nbeforeMount <span class="token operator">-</span><span class="token operator">&gt;</span> onBeforeMount\nmounted <span class="token operator">-</span><span class="token operator">&gt;</span> onMounted\nbeforeUpdate <span class="token operator">-</span><span class="token operator">&gt;</span> onBeforeUpdate\nupdated <span class="token operator">-</span><span class="token operator">&gt;</span> onUpdated\nbeforeDestroy <span class="token operator">-</span><span class="token operator">&gt;</span> onBeforeUnmount\ndestroyed <span class="token operator">-</span><span class="token operator">&gt;</span> onUnmounted\nerrorCaptured <span class="token operator">-</span><span class="token operator">&gt;</span> onErrorCaptured\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="vue3相对于vue2做了哪些优化" tabindex="-1"><a class="header-anchor" href="#vue3相对于vue2做了哪些优化"><span>Vue3相对于Vue2做了哪些优化</span></a></h3><ol><li>重写数据劫持，使用proxy；</li><li>静态节点标记，会区分静态节点和动态节点，只对比动态节点，vue2是全量对比；</li><li>静态提升，不参与更新的节点，会做静态提升，只被创建一次，渲染时直接复用；</li><li>缓存事件处理函数，对事件处理函数进行了缓存，避免了每次渲染时都需要重新创建处理函数；</li><li>移除多余api；</li><li>支持Composition API；</li></ol><h3 id="讲一下vue3相比vue2-它在diff算法上做了哪些优化" tabindex="-1"><a class="header-anchor" href="#讲一下vue3相比vue2-它在diff算法上做了哪些优化"><span>讲一下Vue3相比Vue2，它在diff算法上做了哪些优化？</span></a></h3><ul><li><p><strong>1. 静态节点提升</strong>，在编译阶段，会将静态节点提升到渲染函数之外。这些节点在后续的渲染中会被完全跳过 <code>diff</code>过程，直接复用。</p></li><li><p><strong>2. 基于最长递增子序列的优化</strong>，<code>Vue3</code>在双端比较之后的中间乱序部分，基于动态规划的思想，使用贪心算法和二分查找最长递增子序列，找出需要移动的最小元素集合，最大程度地复用DOM节点。</p></li><li><p><strong>3. Patch Flags (补丁标志)</strong>，为每个动态节点生成一个二进制的标志位，即<code>Patch Flags</code>；这些标志位表示了该节点可能发生的变化。在<code>diff</code>过程中，<code>Vue3</code>会首先检查节点的<code>Patch Flags</code>。如果一个节点没有<code>Patch Flags</code>，说明它是静态节点，直接跳过<code>diff</code>。如果一个节点有<code>Patch Flags</code>，则根据标志位来判断需要进行哪些比较和更新。例如，如果一个节点的<code>Patch Flags</code>只包含<code>TEXT</code>，那么只需要比较和更新文本内容即可，无需比较其他属性或子节点。</p></li></ul>',7),o=(0,a.Fv)('<h3 id="vue的双端比较算法" tabindex="-1"><a class="header-anchor" href="#vue的双端比较算法"><span>Vue的双端比较算法</span></a></h3><p>Vue的双端比较算法是一种优化虚拟DOM diff过程的策略。它通过同时从新旧虚拟DOM树的两端开始比较，向中间遍历来查找差异，使得查找的效率更高。</p><p>具体来说，双端比较算法的过程如下：</p><ol><li><p>在旧虚拟DOM树和新虚拟DOM树的两端分别设置两个指针，分别指向首尾节点。</p></li><li><p>比较两个指针所指向的节点是否相同，如果相同则继续比较下一个节点，否则转到步骤3。</p></li><li><p>判断当前的节点是否为常规节点（例如div、p等），如果是则进一步比较子节点，否则直接将旧节点替换为新节点。</p></li><li><p>每次比较时，先尝试将旧指针向前移动一步，再比较两个指针所指向的节点是否相同。如果相同则重复步骤2，否则将旧指针回退到原位置，并尝试将新指针向后移动一步。如果相同则重复步骤2，否则将新节点插入到DOM中。</p></li><li><p>当新旧指针重合时，比较结束，剩余的未处理节点会被直接插入或删除。</p></li></ol><p>通过使用双端比较算法，Vue可以在虚拟DOM diff过程中，尽可能地减少需要比较的节点数，从而提高性能。同时，由于该算法只是为了优化diff过程，因此仍然需要使用Key属性来帮助Vue跟踪节点的身份，以避免不必要的DOM操作。</p><h3 id="vue的响应式原理" tabindex="-1"><a class="header-anchor" href="#vue的响应式原理"><span>Vue的响应式原理</span></a></h3><ul><li><p><strong>数据劫持/代理</strong></p><p><code>defineProperty</code>/<code>proxy</code></p></li><li><p><strong>依赖收集</strong></p><p>当数据被访问（触发getter）时，会进行依赖收集，存在deps中，用于管理所有依赖该属性的<code>Watcher</code>；</p></li><li><p>Dep的核心方法：</p><ul><li><code>depend()</code>：添加当前活跃的<code>Watcher</code>到依赖中。</li><li><code>notify()</code>：数据更新后通知所有依赖的<code>Watcher</code>。 当数据被修改（触发setter）时，会触发更新逻辑。</li></ul></li><li><p><strong>依赖更新</strong></p><p>通过<code>Dep.notify</code>来通知<code>Watcher</code>更新。</p><p><code>Dep</code>遍历所有依赖的<code>Watcher</code>，逐个调用<code>Watcher</code>的<code>update()</code> 方法,<code>Watcher</code>被标记为“脏”状态，推入更新队列。</p><p><code>Vue</code>合并同一<code>Watcher</code>，确保每个<code>Watcher</code>只会执行一次。 在下一次事件循环（通过<code>Promise.then</code>或<code>setTimeout</code>）中统一处理更新队列。</p><p>调用<code>Watcher</code>的<code>run()</code>方法，执行对应的渲染逻辑（会调用组件的更新函数）或回调函数。</p></li><li><p><strong>DOM更新</strong></p><ul><li>虚拟DOM更新 渲染<code>Watcher</code>调用组件的渲染函数，生成新的虚拟<code>DOM</code>。 <code>Vue</code>对比新旧虚拟<code>DOM</code>（Diff算法），计算出最小的<code>DOM</code>修改操作。</li><li>真实DOM更新 根据<code>Diff</code>算法的结果，<code>Vue</code>更新最小范围的真实<code>DOM</code>，完成页面更新。</li></ul></li></ul><h3 id="vue的diff更新过程" tabindex="-1"><a class="header-anchor" href="#vue的diff更新过程"><span>Vue的diff更新过程</span></a></h3><p><strong>创建VNode：</strong></p><ul><li>Vue.js 通过编译器将模板转换为渲染函数，或直接使用手写的渲染函数。</li><li>渲染函数执行后返回一个 VNode 树，每个 VNode 对象描述了一个真实 DOM 节点，并包含其标签名、属性、子节点等信息。</li></ul><p><strong>比较VNode：</strong></p><ul><li>Vue.js会将新旧两个 VNode 树进行比较，找出需要更新的节点。这个比较过程是基于双指针算法，同时进行深度优先遍历，查找差异。</li><li>Vue.js会使用一个索引记录每个节点在新旧 VNode 树中的位置，以便快速对比。</li><li>首先会比较根节点，判断它们是否相同。如果不同，直接替换整个根节点。</li><li>如果根节点相同，则递归比较子节点，查找差异。</li><li>相同节点的比较：如果新旧两个 VNode 对象的 key 和标签名相同，Vue.js 会认为它们是相同节点，然后进一步比较其属性和子节点。</li><li>不同节点的比较：如果新旧两个 VNode 对象不相同，Vue.js 会直接替换旧节点为新节点。</li></ul><p><strong>应用更新：</strong></p><ul><li>在比较过程中，Vue.js 会记录需要更新的节点，将这些变更应用到真实的 DOM 上，完成视图的更新。</li><li>Vue.js 会尽量复用已存在的 DOM 节点，减少不必要的 DOM 操作，提高性能。 如果存在无法复用的节点，Vue.js 会销毁旧节点，并创建新节点，替换到正确的位置。</li></ul><h3 id="proxy只会代理对象的第一层-那么vue3又是怎样处理这个问题的呢" tabindex="-1"><a class="header-anchor" href="#proxy只会代理对象的第一层-那么vue3又是怎样处理这个问题的呢"><span>Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？</span></a></h3><p>判断当前Reflect.get的返回值是否为Object，如果是则再通过reactive方法做代理， 这样就实现了深度观测。</p><h3 id="监测数组的时候可能触发多次get-set-那么如何防止触发多次呢" tabindex="-1"><a class="header-anchor" href="#监测数组的时候可能触发多次get-set-那么如何防止触发多次呢"><span>监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？</span></a></h3><p>可以判断key是否为当前被代理对象target自身属性，也可以判断旧值与新值是否相等，只有满足以上两个条件之一时，才有可能执行trigger。</p><h3 id="template怎么生成真实dom" tabindex="-1"><a class="header-anchor" href="#template怎么生成真实dom"><span>template怎么生成真实dom</span></a></h3><p>Vue的模版编译过程主要如下：template -&gt; ast -&gt; render函数 -&gt; 虚拟DOM -&gt; 真实DOM</p><ol><li><strong>读取模板：</strong> Vue 会读取 HTML 模板并将其转换为字符串。</li><li><strong>解析模板：</strong> Vue 使用编译器将字符串模板转换为抽象语法树（AST），其中包含模板中的每个元素和它们的属性。</li><li><strong>生成 render 函数：</strong> Vue 使用抽象语法树生成 render 函数。</li><li><strong>数据响应：</strong> Vue 将数据绑定到 render 函数，并使用 Object.defineProperty 监听数据的变化，在数据更改时重新生成 render 函数。</li><li><strong>虚拟 DOM：</strong> Vue 通过 render 函数生成虚拟 DOM，该数据结构是真实 DOM 的内存版本。</li><li><strong>更新 DOM：</strong> Vue 通过对比虚拟 DOM 和真实 DOM 的差异，仅更新需要更新的部分，从而生成最终的真实 DOM。</li></ol>',21),l={href:"https://blog.csdn.net/qq_38261819/article/details/129038001",target:"_blank",rel:"noopener noreferrer"},p=(0,a.Fv)('<h3 id="vue3多节点怎么实现的" tabindex="-1"><a class="header-anchor" href="#vue3多节点怎么实现的"><span>Vue3多节点怎么实现的</span></a></h3><p>是通过 Vue 的编译器将模板中的多个根节点转换为一个片段，并生成相应的渲染函数。在运行时，Vue 的渲染器会正确处理这个片段，并将其渲染到页面上</p><h3 id="为什么vue没有fiber" tabindex="-1"><a class="header-anchor" href="#为什么vue没有fiber"><span>为什么Vue没有fiber</span></a></h3><p>Vue 使用了 Object.defineProperty 或 Proxy 来劫持数据的访问和修改操作，以便能够追踪依赖并在数据变化时触发相应的更新。当数据发生改变时，Vue 会通过异步的 nextTick 机制将视图的更新推迟到下一个事件循环中，以此来减少不必要的重复渲染</p><h3 id="vue的nexttick是怎么实现的" tabindex="-1"><a class="header-anchor" href="#vue的nexttick是怎么实现的"><span>Vue的nextTick是怎么实现的？</span></a></h3><p>如何降级兼容</p><h3 id="vue3的setup做了什么" tabindex="-1"><a class="header-anchor" href="#vue3的setup做了什么"><span>vue3的setup做了什么</span></a></h3><h3 id="router路由的原理" tabindex="-1"><a class="header-anchor" href="#router路由的原理"><span>router路由的原理</span></a></h3><h3 id="slot插槽类型-原理实现" tabindex="-1"><a class="header-anchor" href="#slot插槽类型-原理实现"><span>slot插槽类型，原理实现</span></a></h3><h3 id="scoped原理" tabindex="-1"><a class="header-anchor" href="#scoped原理"><span>scoped原理</span></a></h3><h3 id="为什么vue3中用reflect来操作数据" tabindex="-1"><a class="header-anchor" href="#为什么vue3中用reflect来操作数据"><span>为什么Vue3中用reflect来操作数据</span></a></h3><p><strong><code>Reflect</code></strong> 是为了在执行对应的拦截操作的方法时能 <strong>传递正确的 <code>this</code> 上下文</strong>。</p><h3 id="vuex的原理" tabindex="-1"><a class="header-anchor" href="#vuex的原理"><span>Vuex的原理</span></a></h3><h3 id="vuex和pina通知数据更新" tabindex="-1"><a class="header-anchor" href="#vuex和pina通知数据更新"><span>Vuex和pina通知数据更新</span></a></h3><p>Vuex</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token function">created</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>unsubscribe <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">mutation<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;mutation type:&#39;</span><span class="token punctuation">,</span> mutation<span class="token punctuation">.</span>type<span class="token punctuation">)</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;new state:&#39;</span><span class="token punctuation">,</span> state<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token function">beforeDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unsubscribe</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 取消订阅</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>pina</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token function">useStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 订阅状态变化</span>\nstore<span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">mutation<span class="token punctuation">,</span> state</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;mutation type:&#39;</span><span class="token punctuation">,</span> mutation<span class="token punctuation">.</span>type<span class="token punctuation">)</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&#39;new state:&#39;</span><span class="token punctuation">,</span> state<span class="token punctuation">)</span>\n  \n  <span class="token comment">// 在这里可以执行页面数据更新的操作</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="vue3中watch和watcheffect的区别" tabindex="-1"><a class="header-anchor" href="#vue3中watch和watcheffect的区别"><span>Vue3中watch和watchEffect的区别</span></a></h3>',19),i={},c=(0,s(6262).A)(i,[["render",function(e,n){const s=(0,a.g2)("RouteLink"),i=(0,a.g2)("ExternalLinkIcon");return(0,a.uX)(),(0,a.CE)("div",null,[t,(0,a.Lk)("p",null,[(0,a.bF)(s,{to:"/blogs/note/vue/7.Vue3%E7%9B%B8%E6%AF%94Vue2%EF%BC%8C%E5%AE%83%E5%9C%A8diff%E7%AE%97%E6%B3%95%E4%B8%8A%E5%81%9A%E7%9A%84%E4%BC%98%E5%8C%96.html"},{default:(0,a.k6)((()=>[(0,a.eW)("更多内容")])),_:1})]),o,(0,a.Lk)("p",null,[(0,a.eW)("原文链接："),(0,a.Lk)("a",l,[(0,a.eW)("https://blog.csdn.net/qq_38261819/article/details/129038001"),(0,a.bF)(i)])]),p])}]]),u=JSON.parse('{"path":"/blogs/interview/vue.html","title":"高频面试题中的Vue（补充中...）","lang":"en-US","frontmatter":{"title":"高频面试题中的Vue（补充中...）","date":"2025-01-16T00:00:00.000Z","categories":["interview"],"tags":["Vue"]},"headers":[{"level":3,"title":"Vue2/Vue3生命周期区别","slug":"vue2-vue3生命周期区别","link":"#vue2-vue3生命周期区别","children":[]},{"level":3,"title":"Vue3相对于Vue2做了哪些优化","slug":"vue3相对于vue2做了哪些优化","link":"#vue3相对于vue2做了哪些优化","children":[]},{"level":3,"title":"讲一下Vue3相比Vue2，它在diff算法上做了哪些优化？","slug":"讲一下vue3相比vue2-它在diff算法上做了哪些优化","link":"#讲一下vue3相比vue2-它在diff算法上做了哪些优化","children":[]},{"level":3,"title":"Vue的双端比较算法","slug":"vue的双端比较算法","link":"#vue的双端比较算法","children":[]},{"level":3,"title":"Vue的响应式原理","slug":"vue的响应式原理","link":"#vue的响应式原理","children":[]},{"level":3,"title":"Vue的diff更新过程","slug":"vue的diff更新过程","link":"#vue的diff更新过程","children":[]},{"level":3,"title":"Proxy只会代理对象的第一层，那么Vue3又是怎样处理这个问题的呢？","slug":"proxy只会代理对象的第一层-那么vue3又是怎样处理这个问题的呢","link":"#proxy只会代理对象的第一层-那么vue3又是怎样处理这个问题的呢","children":[]},{"level":3,"title":"监测数组的时候可能触发多次get/set，那么如何防止触发多次呢？","slug":"监测数组的时候可能触发多次get-set-那么如何防止触发多次呢","link":"#监测数组的时候可能触发多次get-set-那么如何防止触发多次呢","children":[]},{"level":3,"title":"template怎么生成真实dom","slug":"template怎么生成真实dom","link":"#template怎么生成真实dom","children":[]},{"level":3,"title":"Vue3多节点怎么实现的","slug":"vue3多节点怎么实现的","link":"#vue3多节点怎么实现的","children":[]},{"level":3,"title":"为什么Vue没有fiber","slug":"为什么vue没有fiber","link":"#为什么vue没有fiber","children":[]},{"level":3,"title":"Vue的nextTick是怎么实现的？","slug":"vue的nexttick是怎么实现的","link":"#vue的nexttick是怎么实现的","children":[]},{"level":3,"title":"vue3的setup做了什么","slug":"vue3的setup做了什么","link":"#vue3的setup做了什么","children":[]},{"level":3,"title":"router路由的原理","slug":"router路由的原理","link":"#router路由的原理","children":[]},{"level":3,"title":"slot插槽类型，原理实现","slug":"slot插槽类型-原理实现","link":"#slot插槽类型-原理实现","children":[]},{"level":3,"title":"scoped原理","slug":"scoped原理","link":"#scoped原理","children":[]},{"level":3,"title":"为什么Vue3中用reflect来操作数据","slug":"为什么vue3中用reflect来操作数据","link":"#为什么vue3中用reflect来操作数据","children":[]},{"level":3,"title":"Vuex的原理","slug":"vuex的原理","link":"#vuex的原理","children":[]},{"level":3,"title":"Vuex和pina通知数据更新","slug":"vuex和pina通知数据更新","link":"#vuex和pina通知数据更新","children":[]},{"level":3,"title":"Vue3中watch和watchEffect的区别","slug":"vue3中watch和watcheffect的区别","link":"#vue3中watch和watcheffect的区别","children":[]}],"git":{"createdTime":1737108179000,"updatedTime":1737108179000,"contributors":[{"name":"稀饭","email":"lixifan@ane56.com","commits":1}]},"filePathRelative":"blogs/interview/vue.md"}')}}]);