"use strict";(self.webpackChunkxifan_blog=self.webpackChunkxifan_blog||[]).push([[8321],{5179:(e,a,s)=>{s.r(a),s.d(a,{comp:()=>g,data:()=>v});var t=s(641);const n=(0,t.Fv)('<h1 id="" tabindex="-1"><a class="header-anchor" href="#"><span></span></a></h1><h2 id="react" tabindex="-1"><a class="header-anchor" href="#react"><span>React</span></a></h2><h2 id="react的class组件和函数组件的区别" tabindex="-1"><a class="header-anchor" href="#react的class组件和函数组件的区别"><span>react的class组件和函数组件的区别</span></a></h2><ol><li><p>性能 <strong>函数组件</strong>：由于没有实例化、this 绑定和简化的副作用管理，函数组件通常在性能上更具优势，尤其在渲染频繁或需要并发更新的场景下。 <strong>class组件</strong>：实例化、生命周期钩子、this 的管理和函数绑定带来额外的性能开销，但在大多数普通应用场景中，影响不会特别显著。</p></li><li><p>维护性 <strong>函数组件</strong>：由于代码简洁、逻辑集中以及 Hooks 提供的灵活性，函数组件的维护性显著更高。它们也支持逻辑复用和状态共享，代码的可读性和复用性更好。 <strong>class组件</strong>：随着状态和副作用的增加，class 组件的代码可能变得复杂、冗长，而且分散在多个生命周期方法中的逻辑也使得维护变得困难。</p></li></ol><h2 id="setstate发生了什么-与vue修改状态的区别-缓存的实现区别-更新状态的调用顺序区别" tabindex="-1"><a class="header-anchor" href="#setstate发生了什么-与vue修改状态的区别-缓存的实现区别-更新状态的调用顺序区别"><span>setstate发生了什么，与vue修改状态的区别，缓存的实现区别？更新状态的调用顺序区别？</span></a></h2><p>React 在调用 setstate 后，react 会将传入的参数对象和组件当前的状态合并，触发调和过程，在调和过程中，react 会根据新的状态构建 react 元素树重新渲染整个 UI 界面，在得到元素树之后，react 会自动计算新老节点的差异，根据差异对界面进行最小化重新渲染</p><h2 id="usestate的原理" tabindex="-1"><a class="header-anchor" href="#usestate的原理"><span>useState的原理</span></a></h2><h2 id="为什么usestate是数组" tabindex="-1"><a class="header-anchor" href="#为什么usestate是数组"><span>为什么useState是数组</span></a></h2><ol><li>解构赋值的便捷性</li></ol><p>使用数组而不是对象，可以利用数组解构赋值的简洁性和便利性。数组解构赋值在语法上更简单，且可以方便地命名状态值和更新函数。</p><p>例如：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>比起对象解构赋值，数组解构赋值显得更加简洁：</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 如果返回的是对象</span>\n<span class="token keyword">const</span> <span class="token punctuation">{</span> <span class="token literal-property property">state</span><span class="token operator">:</span> count<span class="token punctuation">,</span> <span class="token literal-property property">setState</span><span class="token operator">:</span> setCount <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="usestate同步还是异步" tabindex="-1"><a class="header-anchor" href="#usestate同步还是异步"><span>usestate同步还是异步</span></a></h2><h2 id="react的hooks有哪些" tabindex="-1"><a class="header-anchor" href="#react的hooks有哪些"><span>react的hooks有哪些</span></a></h2><h3 id="状态的流转相关" tabindex="-1"><a class="header-anchor" href="#状态的流转相关"><span>状态的流转相关</span></a></h3><p><code>useState</code> 定义状态，大概的原理就是接收一个初始值，内部定义一个修改函数，最终return内部操作的变量和修改函数； <code>useReducer</code> 管理组件内的状态； <code>useContext</code> 具有层级关系的组件中父子、祖孙传值；</p><h3 id="处理副作用相关" tabindex="-1"><a class="header-anchor" href="#处理副作用相关"><span>处理副作用相关</span></a></h3><p><code>useEffect</code> 执行副作用操作和处理生命周期事件； <code>useLayoutEffect</code> 在浏览器布局（layout）完成之后同步执行，在组件挂载后、更新后、卸载前运行，执行优先级比useEffect更高；</p><h3 id="提高操作自由度相关" tabindex="-1"><a class="header-anchor" href="#提高操作自由度相关"><span>提高操作自由度相关</span></a></h3><p><code>useRef</code> 创建一个可以修改的引用对象，1.保存一个不会引起页面重新渲染的变量；2.关联dom标签，操作dom；</p><h3 id="性能优化相关" tabindex="-1"><a class="header-anchor" href="#性能优化相关"><span>性能优化相关</span></a></h3><p><code>useMemo</code> 缓存页面数据，避免重复渲染页面，数据没变化就不会渲染页面； <code>useCallback</code> 缓存函数的引用，不会被重新创建；</p><h3 id="调试相关" tabindex="-1"><a class="header-anchor" href="#调试相关"><span>调试相关</span></a></h3><p><code>useDebugValue</code> 在开发者工具中显示hooks中的变量值</p>',26),l={href:"https://mp.weixin.qq.com/s/ez9oeTSdjuOUkj7s8EqZKg",target:"_blank",rel:"noopener noreferrer"},c=(0,t.Lk)("h2",{id:"react-fiber",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#react-fiber"},[(0,t.Lk)("span",null,"react fiber")])],-1),r=(0,t.Lk)("h3",{id:"什么是fiber",tabindex:"-1"},[(0,t.Lk)("a",{class:"header-anchor",href:"#什么是fiber"},[(0,t.Lk)("span",null,"什么是fiber")])],-1),i=(0,t.Lk)("p",null,"Fiber是React中一种用于实现虚拟DOM和组件协调的新的架构,用于优化渲染过程、实现异步渲染；",-1),o=(0,t.Lk)("p",null,"Fiber还可以理解为是一种数据结构，React Fiber 就是采用链表实现的。每个 Virtual DOM 都可以表示为一个 fiber；",-1),d=(0,t.Lk)("p",null,"每个节点都是一个 fiber。一个 fiber 包括了 child第一个子节点、sibling兄弟节点、return父节点等属性，React Fiber 机制的实现，就是依赖于以下的数据结构。每个 fiber 树它可以由多个子 fiber 组成；",-1),p=(0,t.Lk)("p",null,"在 React 的 fiber 中多次更新最多会存在两棵 Fiber 树，显示在屏幕上的叫做 current Fiber 树，正在内存构建的是 workInProgress Fiber 树",-1),h={href:"https://juejin.cn/post/7258881840823844920",target:"_blank",rel:"noopener noreferrer"},u=(0,t.Fv)('<h3 id="解决了什么问题" tabindex="-1"><a class="header-anchor" href="#解决了什么问题"><span>解决了什么问题</span></a></h3><p>在 Fiber 之前，React 使用的协调算法有一个主要的限制，即一旦开始渲染，就必须同步完成整个组件树的渲染。这意味着 React 无法中断工作以确保主线程的响应性。对于大型应用或复杂界面更新，这可能导致主线程阻塞，从而影响到动画的流畅度、输入响应等。</p><h3 id="特性" tabindex="-1"><a class="header-anchor" href="#特性"><span>特性</span></a></h3><p><strong>增量渲染</strong>：Fiber能够将渲染工作分割成多个小任务，而不是像以前那样一次性处理整个组件树。这样React可以根据需要在多个帧上分配这些任务。</p><p>**任务可中断：**Fiber 架构允许 React 暂停正在进行的工作，先执行更高优先级的工作，然后再回来完成之前的工作。这使得 React 可以保持应用的响应性，即使在大量更新发生时也是如此。</p><p>**更好的优先级管理：**Fiber 允许 React 根据任务的重要性给它们分配不同的优先级。例如，动画更新可以被赋予高优先级，而数据抓取则可以是低优先级。</p><h2 id="react的diff" tabindex="-1"><a class="header-anchor" href="#react的diff"><span>react的diff</span></a></h2>',7),k={href:"https://juejin.cn/post/7274146202496827450",target:"_blank",rel:"noopener noreferrer"},b=(0,t.Fv)('<h2 id="说下hoc高阶组件" tabindex="-1"><a class="header-anchor" href="#说下hoc高阶组件"><span>说下HOC高阶组件</span></a></h2><h2 id="redux的流程" tabindex="-1"><a class="header-anchor" href="#redux的流程"><span>redux的流程</span></a></h2><h2 id="usememo和usecallback的区别" tabindex="-1"><a class="header-anchor" href="#usememo和usecallback的区别"><span>usememo和usecallback的区别</span></a></h2><h2 id="react的生命周期" tabindex="-1"><a class="header-anchor" href="#react的生命周期"><span>react的生命周期</span></a></h2><h2 id="react-修改数据之后是如何触发页面更新-setstate发生的东西" tabindex="-1"><a class="header-anchor" href="#react-修改数据之后是如何触发页面更新-setstate发生的东西"><span>react 修改数据之后是如何触发页面更新，setstate发生的东西</span></a></h2><h2 id="react的fiber如何中断渲染" tabindex="-1"><a class="header-anchor" href="#react的fiber如何中断渲染"><span>react的fiber如何中断渲染</span></a></h2><h2 id="react的状态管理修改值之后-如何触发页面更新" tabindex="-1"><a class="header-anchor" href="#react的状态管理修改值之后-如何触发页面更新"><span>react的状态管理修改值之后，如何触发页面更新</span></a></h2><h2 id="为什么hooks不能写在if判断或者循环中" tabindex="-1"><a class="header-anchor" href="#为什么hooks不能写在if判断或者循环中"><span>为什么hooks不能写在if判断或者循环中</span></a></h2><p><code>React</code>需要依赖<code>Hook</code>调用的顺序来保持组件状态和副作用的正确管理。如果在条件语句或循环中使用<code>Hooks</code>，就无法保证它们的调用顺序是固定的，从而可能导致<code>React</code>无法正确地管理组件状态和副作用。</p><p>具体原因如下：</p><ol><li><p><strong>保持稳定的调用顺序</strong>：<code>React</code>通过每次渲染时以相同的顺序调用<code>Hooks</code>来确定它们的作用。因为<code>React</code>需要知道哪个状态或副作用与哪个<code>Hook</code>关联，如果<code>Hooks</code>在每次渲染时调用顺序不同，就会导致<code>React</code>无法正确管理它们。</p></li><li><p><strong>避免多次执行</strong>：<code>Hooks</code>的调用次数必须在每次组件渲染时保持不变。如果在条件语句中使用<code>Hooks</code>，只有在条件满足时才会调用，这可能导致<code>Hooks</code>的调用次数不稳定，导致<code>React</code>出现错误。</p></li></ol>',11),f={},g=(0,s(6262).A)(f,[["render",function(e,a){const s=(0,t.g2)("ExternalLinkIcon");return(0,t.uX)(),(0,t.CE)("div",null,[n,(0,t.Lk)("p",null,[(0,t.eW)("不想写了，都在这个"),(0,t.Lk)("a",l,[(0,t.eW)("链接里"),(0,t.bF)(s)])]),c,r,i,o,d,p,(0,t.Lk)("p",null,[(0,t.Lk)("a",h,[(0,t.eW)("https://juejin.cn/post/7258881840823844920"),(0,t.bF)(s)])]),u,(0,t.Lk)("p",null,[(0,t.Lk)("a",k,[(0,t.eW)("https://juejin.cn/post/7274146202496827450"),(0,t.bF)(s)])]),b])}]]),v=JSON.parse('{"path":"/blogs/interview/react.html","title":"","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"React","slug":"react","link":"#react","children":[]},{"level":2,"title":"react的class组件和函数组件的区别","slug":"react的class组件和函数组件的区别","link":"#react的class组件和函数组件的区别","children":[]},{"level":2,"title":"setstate发生了什么，与vue修改状态的区别，缓存的实现区别？更新状态的调用顺序区别？","slug":"setstate发生了什么-与vue修改状态的区别-缓存的实现区别-更新状态的调用顺序区别","link":"#setstate发生了什么-与vue修改状态的区别-缓存的实现区别-更新状态的调用顺序区别","children":[]},{"level":2,"title":"useState的原理","slug":"usestate的原理","link":"#usestate的原理","children":[]},{"level":2,"title":"为什么useState是数组","slug":"为什么usestate是数组","link":"#为什么usestate是数组","children":[]},{"level":2,"title":"usestate同步还是异步","slug":"usestate同步还是异步","link":"#usestate同步还是异步","children":[]},{"level":2,"title":"react的hooks有哪些","slug":"react的hooks有哪些","link":"#react的hooks有哪些","children":[{"level":3,"title":"状态的流转相关","slug":"状态的流转相关","link":"#状态的流转相关","children":[]},{"level":3,"title":"处理副作用相关","slug":"处理副作用相关","link":"#处理副作用相关","children":[]},{"level":3,"title":"提高操作自由度相关","slug":"提高操作自由度相关","link":"#提高操作自由度相关","children":[]},{"level":3,"title":"性能优化相关","slug":"性能优化相关","link":"#性能优化相关","children":[]},{"level":3,"title":"调试相关","slug":"调试相关","link":"#调试相关","children":[]}]},{"level":2,"title":"react fiber","slug":"react-fiber","link":"#react-fiber","children":[{"level":3,"title":"什么是fiber","slug":"什么是fiber","link":"#什么是fiber","children":[]},{"level":3,"title":"解决了什么问题","slug":"解决了什么问题","link":"#解决了什么问题","children":[]},{"level":3,"title":"特性","slug":"特性","link":"#特性","children":[]}]},{"level":2,"title":"react的diff","slug":"react的diff","link":"#react的diff","children":[]},{"level":2,"title":"说下HOC高阶组件","slug":"说下hoc高阶组件","link":"#说下hoc高阶组件","children":[]},{"level":2,"title":"redux的流程","slug":"redux的流程","link":"#redux的流程","children":[]},{"level":2,"title":"usememo和usecallback的区别","slug":"usememo和usecallback的区别","link":"#usememo和usecallback的区别","children":[]},{"level":2,"title":"react的生命周期","slug":"react的生命周期","link":"#react的生命周期","children":[]},{"level":2,"title":"react 修改数据之后是如何触发页面更新，setstate发生的东西","slug":"react-修改数据之后是如何触发页面更新-setstate发生的东西","link":"#react-修改数据之后是如何触发页面更新-setstate发生的东西","children":[]},{"level":2,"title":"react的fiber如何中断渲染","slug":"react的fiber如何中断渲染","link":"#react的fiber如何中断渲染","children":[]},{"level":2,"title":"react的状态管理修改值之后，如何触发页面更新","slug":"react的状态管理修改值之后-如何触发页面更新","link":"#react的状态管理修改值之后-如何触发页面更新","children":[]},{"level":2,"title":"为什么hooks不能写在if判断或者循环中","slug":"为什么hooks不能写在if判断或者循环中","link":"#为什么hooks不能写在if判断或者循环中","children":[]}],"git":{"createdTime":1737108179000,"updatedTime":1737108179000,"contributors":[{"name":"稀饭","email":"lixifan@ane56.com","commits":1}]},"filePathRelative":"blogs/interview/react.md"}')}}]);