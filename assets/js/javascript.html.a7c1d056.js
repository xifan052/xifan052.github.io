"use strict";(self.webpackChunkxifan_blog=self.webpackChunkxifan_blog||[]).push([[9339],{9434:(n,s,a)=>{a.r(s),a.d(s,{comp:()=>i,data:()=>r});var e=a(641);const t=(0,e.Fv)('<h2 id="为什么需要虚拟dom-🏳️‍🌈" tabindex="-1"><a class="header-anchor" href="#为什么需要虚拟dom-🏳️‍🌈"><span>为什么需要虚拟dom 🏳️‍🌈</span></a></h2><ul><li>减少对真实dom无意义的改动。</li><li>抽象一个界面表示方式，消除平台之间的差异，来适应不同应用端。</li></ul><h2 id="事件冒泡和事件捕获" tabindex="-1"><a class="header-anchor" href="#事件冒泡和事件捕获"><span>事件冒泡和事件捕获</span></a></h2><p><strong>事件冒泡</strong>（默认）是指在触发某个元素上的特定事件后，该事件将从最内层的元素开始，逐级向上冒泡传播到更外层的祖先元素。</p><p><strong>事件捕获</strong>（注册事件的第三个参数设置设置为true），与事件冒泡相对应的另一种事件传播机制，事件从最外层的祖先元素开始传播，逐级向下捕获，直到达到触发事件的最内层元素。</p><h2 id="js的事件循环" tabindex="-1"><a class="header-anchor" href="#js的事件循环"><span>js的事件循环</span></a></h2><p><strong>1. 同步任务：</strong> 立即执行，先压入调用栈。</p><p><strong>2. 异步任务：</strong> 被分为宏任务和微任务，分别放入各自的队列。</p><p><strong>3. 微任务（Promises.then,Promise.catch,resove,reject,MutationObserver）：</strong> 会优先执行微任务队列中的所有任务。</p><p><strong>4. 宏任务（setTimeout,setInterval,setImmediate）：</strong> 微任务执行完毕后，事件循环才会执行宏任务队列中的任务。</p><ul><li><strong>PS：requestAnimationFrame</strong> 不是同步任务，它的回调是异步执行的，它的任务类型独立于宏任务和微任务，与浏览器的渲染循环直接相关。</li></ul>',11),p={href:"https://juejin.cn/post/7016298598883131423",target:"_blank",rel:"noopener noreferrer"},o=(0,e.Fv)('<h2 id="常用的设计模式" tabindex="-1"><a class="header-anchor" href="#常用的设计模式"><span>常用的设计模式</span></a></h2><ul><li><strong>发布订阅模式</strong>是一种消息传递模式，也被称为消息队列模式。在该模式中，发送者（也称为发布者）将消息发布到消息中心（也称为消息代理或者事件通道），然后多个接收者（也称为订阅者）可以从中获取相应的消息。发布者和订阅者不需要知道对方的存在，只需要与消息中心进行交互，如 event bus 的 on 和 emit。</li><li><strong>观察者模式</strong>当一个对象状态发生改变时，其依赖的其他对象能够自动收到通知并做出相应的响应，如 vue 的 watch 事件。</li><li><strong>策略模式</strong>根据不同的策略执行不同的方法；将方法的的调用与方法的实现分离开来，使得它们可以相互独立地变化，同时也可以避免出现大量的条件语句。</li><li><strong>单例模式</strong>它保证某个类只有一个实例，并且提供了一个全局访问点来访问该实例。</li><li><strong>模块模式</strong>通过使用闭包来实现私有变量和方法，将相关的函数和数据组织在一起。常用于封装模块，避免全局命名空间污染，提供封装和复用性。</li><li><strong>工厂模式</strong>定义一个创建对象的工厂函数，由子类决定实例化哪个类。</li><li><strong>适配器模式</strong>用于将一个类的接口转换成另一个接口，以便那些接口不兼容的类可以一起工作；个人理解为高阶组件，对已有功能进行包装加工。</li></ul><h2 id="箭头函数和普通函数区别-🏳️‍🌈" tabindex="-1"><a class="header-anchor" href="#箭头函数和普通函数区别-🏳️‍🌈"><span>箭头函数和普通函数区别 🏳️‍🌈</span></a></h2><ul><li><strong>this指向</strong>：箭头函数没有自己的this值，它会继承外层作用域的this值。而普通函数中的this值是在运行时确定的，根据调用方式的不同而有所变化。</li><li><strong>arguments对象</strong>：箭头函数没有自己的arguments对象。在箭头函数中使用arguments会引用外层函数的arguments对象。</li><li><strong>构造函数</strong>：箭头函数不能用作构造函数，不能使用new关键字实例化对象(因为没有this)。普通函数可以用作构造函数，创建新的对象实例。</li></ul>',4),l=(0,e.Fv)('<h2 id="构造方法和普通方法的区别" tabindex="-1"><a class="header-anchor" href="#构造方法和普通方法的区别"><span>构造方法和普通方法的区别</span></a></h2><p>构造方法用于初始化对象的状态，而普通方法用于描述对象的行为或功能。</p><p>构造方法在对象创建时自动调用，而普通方法可以在任何时候调用。</p><h2 id="let、const和var的区别-🏳️‍🌈" tabindex="-1"><a class="header-anchor" href="#let、const和var的区别-🏳️‍🌈"><span>let、const和var的区别 🏳️‍🌈</span></a></h2><ul><li><p><strong>作用域</strong></p><p><code>var</code>是函数作用域，就算是在块级结构（如<code>for</code>循环或<code>if</code> 语句）中声明，它也会提升到函数的最顶部，在赋值之前使用会有一个undefined的初始值。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 10，var 没有块级作用域限制</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>let</code>和<code>const</code>是块级作用域，只在声明它们的块（例如<code>for</code>循环、<code>if</code>语句或任何其他类之型的块）内可见，在赋值前使用报错。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错，y 是函数作用域，外部无法访问</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p><strong>变量提升</strong></p></li></ul><p><code>var</code>声明的变量会发生变量提升，即变量声明会被提升到作用域的顶部，但赋值不会提升。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 在变量被正式赋值前，变量的值是 undefined。</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 输出 undefined，声明被提升，但赋值没有</span>\n<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>let</code>和<code>const</code>在块级作用域内，它们会处于“暂时性死区”，直到实际执行声明。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token comment">// 在被声明之前，尝试访问会抛出 ReferenceError 错误。</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错：ReferenceError</span>\n<span class="token keyword">let</span> y <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>z<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 报错：ReferenceError</span>\n<span class="token keyword">const</span> z <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ul><li><p><strong>可变性</strong>：<code>var</code>和<code>let</code>声明的变量可以被重新赋值；<code>const</code>声明的变量不可以重新赋值。</p></li><li><p><strong>重复声明</strong>：<code>let</code>和<code>const</code>重复声明会报错已声明；<code>var</code>重复声明会覆盖之前的声明变量。</p></li></ul><h2 id="es6-和-commonjs-的区别" tabindex="-1"><a class="header-anchor" href="#es6-和-commonjs-的区别"><span>ES6 和 commonjs 的区别</span></a></h2><ol><li><p>语法差异：ES6使用import和export语法来实现模块化，而CommonJS使用require和module.exports语法。</p></li><li><p>加载方式：ES6模块使用静态加载，模块在编译阶段就确定，使得模块依赖关系更加清晰。而CommonJS模块使用动态加载，模块在运行时才能确定，使得模块的加载是同步的。</p></li><li><p>导出方式：ES6模块使用命名导出和默认导出的方式。可以通过export关键字来导出具体的变量、函数或类，也可以使用export default关键字来导出默认的值。而CommonJS模块只支持单一导出，通过module.exports来导出一个对象或者一个函数。</p></li></ol><h2 id="for-of-和for-in的区别" tabindex="-1"><a class="header-anchor" href="#for-of-和for-in的区别"><span>for of 和for in的区别？</span></a></h2><p><strong>for...in</strong> 用于遍历对象和数组（数组会迭代索引）及原型的可枚举属性（键），不保证属性的顺序。</p><p><strong>for...of</strong> 用于遍历数组、字符串、Map、Set等具有迭代器接口对象的值，按照对象的迭代顺序依次访问每个元素。</p><h2 id="set、map、weakset和weakmap的区别" tabindex="-1"><a class="header-anchor" href="#set、map、weakset和weakmap的区别"><span>Set、Map、WeakSet和WeakMap的区别</span></a></h2><p>Set 是一种只能存储唯一值的集合，它不允许重复值，值可以是任何类型。</p><p>Map 是一种键值对的集合，其中键可以是任意类型的值。</p><p>WeakSet 是一种特殊的集合，不能存储原始类型的值，它只能存储对象引用，并且这些引用是弱引用，不会阻止对象被垃圾回收。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code>\n<span class="token keyword">let</span> weakSet <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">let</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;Alice&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token literal-property property">name</span><span class="token operator">:</span> <span class="token string">&quot;Bob&quot;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nweakSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>\nweakSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>weakSet<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span>\n\nobj1 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// obj1 置为 null 后，对象可以被垃圾回收</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>WeakMap 是一种特殊的键值对集合，其中的键是弱引用，而值可以是任意类型的值。</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">let</span> weakMap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">let</span> key1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> key2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n\nweakMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key1<span class="token punctuation">,</span> <span class="token string">&quot;value1&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nweakMap<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key2<span class="token punctuation">,</span> <span class="token string">&quot;value2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>weakMap<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key1<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;value1&quot;</span>\n\nkey1 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// key1 置为 null 后，键可以被垃圾回收</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="js垃圾回收" tabindex="-1"><a class="header-anchor" href="#js垃圾回收"><span>js垃圾回收</span></a></h2><ul><li><p><strong>标记清除</strong> 进入执行环境的变量都被标记，然后执行完，清除这些标记跟变量。查看变量是否被引用；标记清除算法能够准确地识别不再使用的内存对象，包括循环引用等复杂情况.</p></li><li><p><strong>引用计数</strong></p><p>引用计数会记录每个值被引用的次数，当引用次数变成0后，就会被释放掉；但由于其无法解决循环引用的问题，通常不被 JavaScript 引擎采用。</p></li><li><p><strong>v8的垃圾回收（分代式垃圾回收策略）</strong> 根据存活周期分为新生代和老生代，存活周期很短，经过一次垃圾回收后,就被释放回收掉为新生代;存活周期很长，经过多次垃圾回收后内存仍存在为老生代； 新生代基于标记-复制回收，通过标记活动对象复制到空闲区，清除垃圾对象； 老生代基于标记-清除和标记-整理回收，标记-清除算法用于标记并清除不再使用的对象，而标记-整理算法则在清除对象后进行内存整理，消除内存碎片；</p></li></ul><h2 id="什么是泛型" tabindex="-1"><a class="header-anchor" href="#什么是泛型"><span>什么是泛型</span></a></h2><p>它允许在编写代码时使用未知类型来定义类、接口和方法,使用类型参数（Type Parameters）来代表未知类型。这些类型参数在使用时被实际的类型替换，从而实现了对不同类型的通用支持</p><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span><span class="token constant">T</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>\n  <span class="token keyword">private</span> <span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token constant">T</span><span class="token punctuation">;</span>\n  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter"><span class="token literal-property property">value</span><span class="token operator">:</span> <span class="token constant">T</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">T</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">let</span> box1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span>string<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token string">&quot;Hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> box2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span>number<span class="token operator">&gt;</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="interface-和-type-的区别" tabindex="-1"><a class="header-anchor" href="#interface-和-type-的区别"><span>interface 和 type 的区别</span></a></h2><p><strong>可扩展</strong>：interface可以通过implements来实现方法，通过extends关键字进行扩展，type可使用交叉类型&amp;合并不同的type或interface，并且可被推导，因为type的类型是明确的。</p><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">type</span> <span class="token class-name">Person</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token builtin">string</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">interface</span> <span class="token class-name">apple</span> <span class="token punctuation">{</span>\n    name<span class="token operator">:</span><span class="token builtin">string</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 通过 extends 关键字进行扩展</span>\n<span class="token keyword">interface</span> <span class="token class-name">appleInfo</span> <span class="token keyword">extends</span> <span class="token class-name">apple</span> <span class="token punctuation">{</span>\n    year<span class="token operator">:</span><span class="token builtin">number</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">const</span> aApple<span class="token operator">:</span>appleInfo <span class="token operator">=</span> <span class="token punctuation">{</span>\n    year<span class="token operator">:</span><span class="token number">50</span><span class="token punctuation">,</span>\n    name<span class="token operator">:</span><span class="token string">&#39;apple&#39;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 使用交叉类型&amp;合并不同的type或interface</span>\n<span class="token class-name"><span class="token keyword">type</span></span> Employee <span class="token operator">=</span> Person <span class="token operator">&amp;</span> <span class="token punctuation">{</span>\n  age<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>\n  salary<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> employee<span class="token operator">:</span> Employee <span class="token operator">=</span> <span class="token punctuation">{</span>\n  name<span class="token operator">:</span> <span class="token string">&quot;Alice&quot;</span><span class="token punctuation">,</span>\n  age<span class="token operator">:</span> <span class="token number">30</span><span class="token punctuation">,</span>\n  salary<span class="token operator">:</span> <span class="token number">5000</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>定义数据类型</strong>：interface一般用于对象的描述；type声明可以声明任何类型，除了对象还可以声明基本类型别名，联合类型，元组等类型。 <strong>重复声明</strong>：interface在定义了两个相同接口会合并。Type 有多个声明会报错。</p><p>总结来说，interface用于声明对象结构；type描述基本类型的数据及类型的关系扩展</p><div class="language-typescript line-numbers-mode" data-ext="ts" data-title="ts"><pre class="language-typescript"><code><span class="token keyword">interface</span> <span class="token class-name">Point</span> <span class="token punctuation">{</span> x<span class="token operator">:</span> <span class="token builtin">number</span><span class="token punctuation">,</span> y<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>\n\n<span class="token keyword">type</span> <span class="token class-name">Point3D</span> <span class="token operator">=</span>Point <span class="token operator">&amp;</span> <span class="token punctuation">{</span> z<span class="token operator">:</span> <span class="token builtin">number</span> <span class="token punctuation">}</span>\n\n<span class="token keyword">type</span> <span class="token class-name">status</span> <span class="token operator">=</span> <span class="token string">&#39;success&#39;</span> <span class="token operator">|</span> <span class="token string">&#39;fail&#39;</span>\n\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="new关键字做了什么" tabindex="-1"><a class="header-anchor" href="#new关键字做了什么"><span>new关键字做了什么</span></a></h2><div class="language-javascript line-numbers-mode" data-ext="js" data-title="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">_new</span><span class="token punctuation">(</span><span class="token parameter">constructor<span class="token punctuation">,</span> <span class="token operator">...</span>arg</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 创建一个空对象</span>\n  <span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n  <span class="token comment">// 空对象的`__proto__`指向构造函数的`prototype`, 为这个新对象添加属性</span>\n  obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span>\n  <span class="token comment">// 构造函数的作用域赋给新对象</span>\n  <span class="token keyword">var</span> res <span class="token operator">=</span> <span class="token function">constructor</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> arg<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// 返回新对象.如果没有显式return语句，则返回this</span>\n  <span class="token keyword">return</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">&#39;[object Object]&#39;</span> <span class="token operator">?</span> res <span class="token operator">:</span> obj<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="说下原型和原型链" tabindex="-1"><a class="header-anchor" href="#说下原型和原型链"><span>说下原型和原型链</span></a></h2><p>每个js对象（除了null、undefined及Object.create(null)）都有一个原型对象，当你访问一个对象的属性时，JavaScript 引擎首先会查找对象自身的属性，如果找不到，就会查找对象的原型，沿着原型链向上查找，直到找到所需属性或到达原型链的末尾（null）。如果仍然找不到，则返回undefined</p><h3 id="如何不让某个原型属性被继承" tabindex="-1"><a class="header-anchor" href="#如何不让某个原型属性被继承"><span>如何不让某个原型属性被继承</span></a></h3><ol><li>设置同名属性，会优先使用本身的属性，不会再去找原型上属性；</li><li>使用<code>Object.defineProperty()</code>设置<code>enumerable</code>（是否可枚举）为<code>false</code>或configurable（是否可修改配置）设置为<code>false</code>；</li></ol><h3 id="proto-和prototype的区别" tabindex="-1"><a class="header-anchor" href="#proto-和prototype的区别"><span>_proto_和prototype的区别</span></a></h3><p><strong><em>proto</em></strong>：这是一个对象的内部属性，指向该对象的原型，也就是它继承的属性和方法的来源。在ES6之前，可以通过Object.prototype的__proto__属性访问或设置一个对象的原型，但这种做法已经不推荐使用，因为__proto__属性在ES6中已被废弃。</p><p><strong>prototype</strong>：这是构造函数的一个属性，它是一个对象，包含了由该构造函数创建的所有实例共享的方法和属性。当你创建一个新实例时，这个实例的_proto_属性会指向这个prototype对象。</p><h3 id="说下js的作用域链" tabindex="-1"><a class="header-anchor" href="#说下js的作用域链"><span>说下js的作用域链</span></a></h3><p><strong>作用域链</strong> 是指在执行代码时，查找变量的过程。</p><p><strong>作用域</strong> 是指变量和函数的可访问范围，分两种：</p><ul><li><p><strong>全局作用域</strong>：在整个代码中任何地方都可以访问的作用域。所有在函数或块作用域外部定义的变量都属于全局作用域。</p></li><li><p><strong>局部作用域</strong>：指在函数或块（例如 {}）内定义的变量，其作用域仅限于函数或块内。</p></li></ul><p>当<code>JavaScript</code>引擎查找变量时，会先从当前作用域查找，如果没有找到，就会向上一级作用域查找，直到全局作用域。如果在所有作用域中都找不到该变量，则抛出<code>ReferenceError</code>错误。</p>',47),c={},i=(0,a(6262).A)(c,[["render",function(n,s){const a=(0,e.g2)("RouteLink"),c=(0,e.g2)("ExternalLinkIcon");return(0,e.uX)(),(0,e.CE)("div",null,[t,(0,e.Lk)("p",null,[(0,e.bF)(a,{to:"/examples/js%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF.html"},{default:(0,e.k6)((()=>[(0,e.eW)("查看代码")])),_:1}),(0,e.eW)(" | "),(0,e.Lk)("a",p,[(0,e.eW)("详细解析"),(0,e.bF)(c)])]),o,(0,e.Lk)("p",null,[(0,e.bF)(a,{to:"/examples/%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E5%92%8C%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%8C%BA%E5%88%AB.html"},{default:(0,e.k6)((()=>[(0,e.eW)("查看代码")])),_:1})]),l])}]]),r=JSON.parse('{"path":"/blogs/interview/javascript.html","title":"高频面试题中的Javascript","lang":"en-US","frontmatter":{"title":"高频面试题中的Javascript","date":"2024-03-19T00:00:00.000Z","categories":["interview"],"tags":["Javascript"]},"headers":[{"level":2,"title":"为什么需要虚拟dom 🏳️‍🌈","slug":"为什么需要虚拟dom-🏳️‍🌈","link":"#为什么需要虚拟dom-🏳️‍🌈","children":[]},{"level":2,"title":"事件冒泡和事件捕获","slug":"事件冒泡和事件捕获","link":"#事件冒泡和事件捕获","children":[]},{"level":2,"title":"js的事件循环","slug":"js的事件循环","link":"#js的事件循环","children":[]},{"level":2,"title":"常用的设计模式","slug":"常用的设计模式","link":"#常用的设计模式","children":[]},{"level":2,"title":"箭头函数和普通函数区别 🏳️‍🌈","slug":"箭头函数和普通函数区别-🏳️‍🌈","link":"#箭头函数和普通函数区别-🏳️‍🌈","children":[]},{"level":2,"title":"构造方法和普通方法的区别","slug":"构造方法和普通方法的区别","link":"#构造方法和普通方法的区别","children":[]},{"level":2,"title":"let、const和var的区别 🏳️‍🌈","slug":"let、const和var的区别-🏳️‍🌈","link":"#let、const和var的区别-🏳️‍🌈","children":[]},{"level":2,"title":"ES6 和 commonjs 的区别","slug":"es6-和-commonjs-的区别","link":"#es6-和-commonjs-的区别","children":[]},{"level":2,"title":"for of 和for in的区别？","slug":"for-of-和for-in的区别","link":"#for-of-和for-in的区别","children":[]},{"level":2,"title":"Set、Map、WeakSet和WeakMap的区别","slug":"set、map、weakset和weakmap的区别","link":"#set、map、weakset和weakmap的区别","children":[]},{"level":2,"title":"js垃圾回收","slug":"js垃圾回收","link":"#js垃圾回收","children":[]},{"level":2,"title":"什么是泛型","slug":"什么是泛型","link":"#什么是泛型","children":[]},{"level":2,"title":"interface 和 type 的区别","slug":"interface-和-type-的区别","link":"#interface-和-type-的区别","children":[]},{"level":2,"title":"new关键字做了什么","slug":"new关键字做了什么","link":"#new关键字做了什么","children":[]},{"level":2,"title":"说下原型和原型链","slug":"说下原型和原型链","link":"#说下原型和原型链","children":[{"level":3,"title":"如何不让某个原型属性被继承","slug":"如何不让某个原型属性被继承","link":"#如何不让某个原型属性被继承","children":[]},{"level":3,"title":"_proto_和prototype的区别","slug":"proto-和prototype的区别","link":"#proto-和prototype的区别","children":[]},{"level":3,"title":"说下js的作用域链","slug":"说下js的作用域链","link":"#说下js的作用域链","children":[]}]}],"git":{"createdTime":1737108179000,"updatedTime":1737108179000,"contributors":[{"name":"稀饭","email":"lixifan@ane56.com","commits":1}]},"filePathRelative":"blogs/interview/javascript.md"}')}}]);