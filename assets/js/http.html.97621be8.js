"use strict";(self.webpackChunkxifan_blog=self.webpackChunkxifan_blog||[]).push([[6060],{6403:(t,e,o)=>{o.r(e),o.d(e,{comp:()=>r,data:()=>n});var s=o(641);const d=[(0,s.Fv)('<h3 id="http版本的区别" tabindex="-1"><a class="header-anchor" href="#http版本的区别"><span>HTTP版本的区别</span></a></h3><h3 id="tcp的三次握手" tabindex="-1"><a class="header-anchor" href="#tcp的三次握手"><span>TCP的三次握手</span></a></h3><ol><li>客户端发送连接请求报文段<code>SYN</code>。</li><li>服务器收到客户端的连接请求报文段<code>SYN</code>后，如果同意建立连接，则会发送一个带有<code>SYN</code>和<code>ACK</code>响应报文。</li><li>客户端收到服务器的响应后，对其进行确认并同意继续连接，服务器收到这个包含<code>ACK</code>的确认后，就完成了三次握手，双方可以开始进行数据传输了。</li></ol><p>以 boss 投简历为例，第一步，向 hr 打招呼；第二步，hr 收到消息并且有意向，就会回应；第三步，收到 hr 的消息之后去发送简历；</p><h4 id="追问" tabindex="-1"><a class="header-anchor" href="#追问"><span>追问</span></a></h4><ol><li><p><strong>为什么是三次握手?</strong></p><p>确保双方都存在，并且能够发送和接收数据，如果只有两次握手，就没有办法确认双方的序列号以及彼此是否都已经准备好接收数据。</p></li><li><p><strong>为什么不是四次或更多次握手?</strong></p><p>在建立连接时并不需要更多的确认步骤。三次握手已经足够完成以下任务：</p><ul><li>确认双方都准备好建立连接。</li><li>确认双方的序列号同步。</li><li>确保双方的通信可靠。</li></ul></li><li><p><strong>如果第二次握手失败会怎么样?</strong></p><p>可能发生以下几种情况：</p><ul><li><strong>超时</strong>：客户端A在规定时间内没有收到服务器端B的<code>SYN/ACK</code>报文段，即超过了连接建立的超时时间。这可能是由于网络延迟、丢包或者服务器端未正常响应等问题导致的。</li><li><strong>拒绝</strong>：服务器端B可能选择拒绝连接请求，例如，基于某些安全策略、负载均衡机制或者连接数限制等原因。</li><li><strong>重传</strong>：客户端A可能会尝试重新发送第一次握手的连接请求，以期望能够重新建立连接。</li></ul></li></ol><h3 id="tcp四次挥手" tabindex="-1"><a class="header-anchor" href="#tcp四次挥手"><span>TCP四次挥手</span></a></h3><ol><li><p>客户端向服务器发送连接释放请求（FIN）报文段。客户端希望关闭连接，并停止发送数据。客户端进入<code>FIN_WAIT_1</code>状态。</p></li><li><p>服务器收到连接释放请求后，发送确认（ACK）报文段作为响应，确认收到了客户端的关闭请求。服务器进入<code>CLOSE_WAIT</code>状态，客户端进入<code>FIN_WAIT_2</code>状态。</p></li><li><p>服务器完成自己未发送的数据的发送后，发送连接释放请求（FIN）报文段给客户端，表示服务器也希望关闭连接。服务器进入<code>LAST_ACK</code>状态。</p></li><li><p>客户端收到服务器的连接释放请求后，发送确认（ACK）报文段作为响应，确认收到了服务器的关闭请求。客户端进入<code>TIME_WAIT</code>状态。此时，服务器等待最后一个ACK的确认。</p></li><li><p>在经过一段时间（通常是两倍的报文段最大生存时间，即2MSL）后，客户端关闭连接，结束<code>TIME_WAIT</code>状态。最后一个ACK被发送到服务器。</p></li></ol><p>在四次挥手完成后，TCP连接正式关闭，客户端和服务器都进入了CLOSED状态。</p><p>需要注意的是，这里的挥手过程中，每个报文段都需要对方进行确认。同时，客户端和服务器都需要维护一些状态来跟踪连接的关闭过程，以保证可靠的连接释放。</p><p>TCP使用四次挥手（Four-Way Handshake）来终止连接，而不是两次、三次或更多次，主要是因为在 TCP 连接终止的过程中，双方都需要确保数据能够可靠地完成传输，同时保证双方都能干净地关闭连接。</p><h4 id="追问-1" tabindex="-1"><a class="header-anchor" href="#追问-1"><span>追问</span></a></h4><ol><li><p><strong>为什么是四次挥手？</strong></p><p>在TCP连接的关闭过程中，每一方都需要通知对方自己已经完成数据的传输，并且准备好关闭连接。由于TCP是全双工的通信协议，即每一方都可以独立发送和接收数据，因此每一方必须独立地关闭自己的发送方向。</p><ol><li><strong>第一次挥手</strong>（主动关闭方发送<code>FIN</code>）： <ul><li>客户端（或主动方）发送一个<code>FIN</code>报文段，表示它已经完成数据发送，准备关闭连接。这个报文段是一个结束数据流的请求。</li><li>客户端进入<strong>FIN_WAIT_1</strong>状态，等待服务器确认。</li></ul></li><li><strong>第二次挥手</strong>（被动关闭方确认<code>FIN</code>）： <ul><li>服务器收到客户端的<code>FIN</code>报文段，表示客户端已经完成发送数据。服务器会响应一个<code>ACK</code>报文段，确认客户端的<code>FIN</code>。</li><li>此时，客户端确认自己的发送方向已经关闭（可以进行数据的清理工作），但服务器可能仍然需要继续发送数据，因此客户端进入<strong>FIN_WAIT_2</strong>状态。</li></ul></li><li><strong>第三次挥手</strong>（被动关闭方发送<code>FIN</code>）： <ul><li>服务器在完成数据发送后，向客户端发送一个<code>FIN</code>报文段，表示服务器也准备关闭连接。此时，服务器进入<strong>LAST_ACK</strong>状态，等待客户端确认。</li></ul></li><li><strong>第四次挥手</strong>（主动关闭方确认<code>FIN</code>）： <ul><li>客户端收到服务器的<code>FIN</code>报文段后，回复一个<code>ACK</code>报文段，表示客户端确认服务器的关闭请求。此时，客户端进入<strong>TIME_WAIT</strong>状态，等待足够的时间确保服务器收到了<code>ACK</code>报文段，然后完全关闭连接。</li><li>服务器收到客户端的确认后，关闭连接。</li></ul></li></ol></li><li><p><strong>为什么不能是两次挥手？</strong></p><p>两次挥手会导致数据的丢失或连接未能完全断开。在四次挥手的过程中，每一方都能够确保自己完成了数据的发送，并且完全理解对方的状态。没有充分的确认步骤会导致以下问题：</p><ul><li>如果只使用两次挥手，可能会导致某一方的数据未完全发送或未完全接收。</li><li>如果没有明确的关闭过程，另一方可能无法确认数据是否全部传输完成。</li></ul></li><li><p><strong>为什么不是五次或更多次挥手？</strong></p><p>增加挥手次数无法进一步提高协议的效率或可靠性。并不会带来更多的好处，反而可能会增加不必要的延迟和复杂度。四次挥手已经涵盖了必要的确认和关闭操作：</p><ul><li>每次挥手都有明确的目的。</li><li>任何额外的挥手都不会提升可靠性或数据完整性，反而会导致不必要的通信开销。</li></ul></li></ol><h3 id="http和https的区别" tabindex="-1"><a class="header-anchor" href="#http和https的区别"><span>HTTP和HTTPS的区别</span></a></h3><ol><li><p><strong>安全性：</strong> <code>HTTP</code>是明文传输协议，数据在传输过程中不经过加密处理，容易被窃听和篡改。<code>HTTPS</code>则通过使用<code>SSL/TLS</code>协议对数据进行加密，确保传输过程中的安全性。</p></li><li><p><strong>默认端口：</strong> <code>HTTP</code>默认使用<strong>端口80</strong>进行通信。<code>HTTPS</code>默认使用<strong>端口443</strong>进行通信。</p></li><li><p><strong>证书要求：</strong> <code>HTTP</code>不需要使用证书。<code>HTTPS</code>使用<code>SSL</code>（Secure Sockets Layer）或<code>TLS</code>（Transport Layer Security）证书来验证服务器的身份，并建立安全连接。</p></li></ol><h3 id="https加密过程或执行过程" tabindex="-1"><a class="header-anchor" href="#https加密过程或执行过程"><span>HTTPS加密过程或执行过程</span></a></h3><p>① 证书验证阶段 浏览器发起<code>HTTPS</code>请求 服务端返回<code>HTTPS</code>证书 客户端验证证书是否合法，如果不合法则提示告警</p><p>② 数据传输阶段 当证书验证合法后，在本地生成随机数 通过公钥加密随机数，并把加密后的随机数传输到服务端 服务端通过私钥对随机数进行解密 服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输</p><h3 id="https中的ssl证书做了什么" tabindex="-1"><a class="header-anchor" href="#https中的ssl证书做了什么"><span>HTTPS中的SSL证书做了什么</span></a></h3><p><strong>身份验证：</strong> <code>SSL</code>证书由可信任的数字证书颁发机构（CA）签发，用于验证服务器的身份。证书中包含了服务器的公钥以及与之相关的信息，确保客户端连接到的是预期的服务器而非恶意伪造的服务器。</p><p><strong>数据加密：</strong> <code>SSL</code>证书中的公钥用于对数据进行加密，并且只有服务器拥有与该证书关联的私钥才能解密数据。这样，即使在传输过程中数据被截获，也无法被解密读取。</p><p><strong>数据完整性：</strong> 在<code>SSL</code>握手过程中，服务器会生成一个消息摘要，并使用私钥对其进行签名。客户端收到数据后可以使用证书中的公钥来验证签名的有效性，确保数据在传输过程中没有被篡改。</p><p><strong>安全连接建立：</strong> 通过<code>SSL</code>证书，客户端和服务器可以协商出一种加密算法和密钥，用于在之后的通信过程中进行加密和解密，确保传输的数据保持机密性和完整性。</p><p>总结起来，<code>HTTPS</code>使用<code>SSL</code>证书实现了数据加密、身份验证和数据完整性保护，从而提供了更高的安全性，适用于需要保护敏感信息（如个人信息、密码等）的网站和应用程序。</p><h3 id="前端攻击" tabindex="-1"><a class="header-anchor" href="#前端攻击"><span>前端攻击</span></a></h3><h4 id="xss攻击" tabindex="-1"><a class="header-anchor" href="#xss攻击"><span>XSS攻击</span></a></h4><p><strong>说明</strong>：在网页中注入JavaScript代码，从而在受害者的浏览器上执行恶意操作 <strong>解决</strong>：过滤用户输入输出及浏览器参数，避免将用户输入内容直接作为html输出到页面</p><h4 id="csrf攻击" tabindex="-1"><a class="header-anchor" href="#csrf攻击"><span>CSRF攻击</span></a></h4><p><strong>说明</strong>：攻击者可以通过伪造请求，发送恶意请求到受信任的网站，欺骗用户进行非预期的操作 <strong>解决</strong>：使用验证码来增加人为干预，并校验当前运行环境的域名信息</p><h4 id="数据窃取" tabindex="-1"><a class="header-anchor" href="#数据窃取"><span>数据窃取</span></a></h4><p><strong>说明</strong>：攻击者通过窃取浏览器的Cookie信息或利用恶意广告注入恶意脚本来窃取网页中的敏感数据 <strong>解决</strong>：使用https协议，并对传输的敏感参数加密</p><h4 id="中间人攻击" tabindex="-1"><a class="header-anchor" href="#中间人攻击"><span>中间人攻击</span></a></h4><p><strong>说明</strong>：攻击者会在通信过程中插入自己作为中间人的位置，使其能够拦截、篡改或窃取通信数据 <strong>解决</strong>：使用vpn，生物认证</p><h4 id="上传文件攻击" tabindex="-1"><a class="header-anchor" href="#上传文件攻击"><span>上传文件攻击</span></a></h4><p><strong>说明</strong>：文件名攻击，上传的文件采用上传之前的文件名，可能造成：客户端和服务端字符码不兼容，导致文件名乱码问题；文件名包含脚本，从而造成攻击。 <strong>解决</strong>：对上传文件名转义或者生成新文件名，隐藏文件真实路径，限制文件大小</p><h3 id="七层网络模型" tabindex="-1"><a class="header-anchor" href="#七层网络模型"><span>七层网络模型</span></a></h3><ul><li><strong>物理层</strong>：负责传输比特流，对应物理介质和网络设备（如网线、集线器）。</li><li><strong>数据链路层</strong>：负责可靠地传输数据帧，对应网桥、交换机等设备。</li><li><strong>网络层</strong>：负责确定数据的路径和地址，对应路由器、防火墙等设备。</li><li><strong>传输层</strong>：负责提供端到端的可靠数据传输，对应传输控制协议（TCP）和用户数据报协议（UDP）等协议。</li><li><strong>会话层</strong>：负责建立、管理和终止会话连接。</li><li><strong>表示层</strong>：负责数据格式转换、数据加密等操作。</li><li><strong>应用层</strong>：提供各种应用服务，例如HTTP、FTP、DNS等。</li></ul><h3 id="http、tcp和websocket之间的区别" tabindex="-1"><a class="header-anchor" href="#http、tcp和websocket之间的区别"><span>HTTP、TCP和WebSocket之间的区别</span></a></h3><table><thead><tr><th>特性</th><th>HTTP</th><th>TCP</th><th>WebSocket</th></tr></thead><tbody><tr><td><strong>协议层级</strong></td><td>应用层</td><td>传输层</td><td>应用层</td></tr><tr><td><strong>连接方式</strong></td><td>无状态，短连接，每个请求完成后，连接会被关闭</td><td>面向连接的协议，长连接</td><td>长连接，支持全双工通信</td></tr><tr><td><strong>数据传输方式</strong></td><td>请求-响应模式，客户端发起请求，服务端响应</td><td>数据以流的方式传输，不关心数据的格式和内容</td><td>双向通信，客户端和服务端双方建立连接后都可主动发送数据</td></tr><tr><td><strong>资源消耗</strong></td><td>每次请求需要建立和关闭连接，资源消耗较高</td><td>连接持续存在，资源消耗低</td><td>连接持续存在，资源消耗低</td></tr><tr><td><strong>实时性</strong></td><td>不支持实时通信</td><td>本身不具备实时性，基于它实现的协议可以实现实时通信</td><td>支持高效的实时通信</td></tr><tr><td><strong>使用场景</strong></td><td>Web 浏览器请求网页资源、API等</td><td>底层协议，用于传输数据</td><td>低延迟、实时更新的场景，实时聊天、在线游戏、股票行情等</td></tr><tr><td><strong>协议头</strong></td><td>协议头较大，包含大量元信息，请求参数、User-Agent等</td><td>协议头较小</td><td>协议头较小，额外元数据少</td></tr><tr><td><strong>可靠性</strong></td><td>依赖于 TCP 的可靠性，本身并不负责重传数据或处理丢包等问题</td><td>提供可靠的数据传输，通过三次握手、四次挥手等</td><td>基于TCP，提供可靠传输</td></tr><tr><td><strong>状态保持</strong></td><td>无状态，需要通过 Cookie 或 Session 实现</td><td>有状态</td><td>有状态</td></tr></tbody></table>',39)],l={},r=(0,o(6262).A)(l,[["render",function(t,e){return(0,s.uX)(),(0,s.CE)("div",null,d)}]]),n=JSON.parse('{"path":"/blogs/interview/http.html","title":"高频面试题中的HTTP（四）","lang":"en-US","frontmatter":{"title":"高频面试题中的HTTP（四）","date":"2024-03-18T00:00:00.000Z","categories":["interview"],"tags":["HTTP"]},"headers":[{"level":3,"title":"HTTP版本的区别","slug":"http版本的区别","link":"#http版本的区别","children":[]},{"level":3,"title":"TCP的三次握手","slug":"tcp的三次握手","link":"#tcp的三次握手","children":[]},{"level":3,"title":"TCP四次挥手","slug":"tcp四次挥手","link":"#tcp四次挥手","children":[]},{"level":3,"title":"HTTP和HTTPS的区别","slug":"http和https的区别","link":"#http和https的区别","children":[]},{"level":3,"title":"HTTPS加密过程或执行过程","slug":"https加密过程或执行过程","link":"#https加密过程或执行过程","children":[]},{"level":3,"title":"HTTPS中的SSL证书做了什么","slug":"https中的ssl证书做了什么","link":"#https中的ssl证书做了什么","children":[]},{"level":3,"title":"前端攻击","slug":"前端攻击","link":"#前端攻击","children":[]},{"level":3,"title":"七层网络模型","slug":"七层网络模型","link":"#七层网络模型","children":[]},{"level":3,"title":"HTTP、TCP和WebSocket之间的区别","slug":"http、tcp和websocket之间的区别","link":"#http、tcp和websocket之间的区别","children":[]}],"git":{"createdTime":1737108179000,"updatedTime":1737108179000,"contributors":[{"name":"稀饭","email":"lixifan@ane56.com","commits":1}]},"filePathRelative":"blogs/interview/http.md"}')}}]);