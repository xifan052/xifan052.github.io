"use strict";(self.webpackChunkxifan_blog=self.webpackChunkxifan_blog||[]).push([[6768],{2454:(e,o,l)=>{l.r(o),l.d(o,{comp:()=>t,data:()=>a});var c=l(641);const d=(0,c.Fv)('<p>应该有很多人面试被问到过输入URL到页面渲染这个问题，这篇内容针对这部分了做了一遍系统的梳理，对http和https的差异、请求过程及页面解析中的细节做了补充和完善。</p><h2 id="_1-地址解析与url分析-📚" tabindex="-1"><a class="header-anchor" href="#_1-地址解析与url分析-📚"><span>1. 地址解析与URL分析 📚</span></a></h2><p>在输入URL之后，首先浏览器检查URL的格式，确定协议（HTTP/HTTPS/FTP），域名，端口（如果有），以及路径。</p><h2 id="_2-dns解析📚" tabindex="-1"><a class="header-anchor" href="#_2-dns解析📚"><span>2. DNS解析📚</span></a></h2><p>确定域名信息之后，就开始进行DNS的解析，DNS(Domain Name System)的全称叫做域名系统，作用是将域名地址转为服务器对应的IP地址；</p><p>浏览器会先检查本地的DNS缓存，查看是否有域名对应的IP地址，如果有就直接返回，如果没有，就向本地的DNS服务器发起查询请求，或者会向更高层的DNS服务器查询，</p><p>整个过程可以大概分为下面几步：</p><ol><li>首先，操作系统会尝试从本地DNS缓存中查找域名对应的IP地址。</li><li>如果本地DNS缓存中没有相应的记录，系统会向根域名服务器发起查询请求。</li><li>根域名服务器会返回顶级域名服务器的地址。</li><li>然后，系统向顶级域名服务器发送查询请求。</li><li>顶级域名服务器会返回权威域名服务器的地址。</li><li>系统向权威域名服务器发送查询请求。</li><li>最终，权威域名服务器返回目标域名对应的IP地址。</li><li>系统将IP地址返回给应用程序，完成域名解析过程。</li></ol><p>总结一下其实就是如果本地没有DNS缓存，就会往向上游服务器查询，上游服务器会返回对应的地址，直到权威域名服务器返回对应的IP地址，中间每一层服务器查询都会缓存结果。</p><h2 id="_3-和服务器建立连接-📚" tabindex="-1"><a class="header-anchor" href="#_3-和服务器建立连接-📚"><span>3. 和服务器建立连接 📚</span></a></h2><p>不管是HTTP，还是HTTPS，都先会通过TCP三次握手建立连接，</p><ol><li>客户端发送一个带有<code>SYN</code>（synchronize同步）标志的数据包给服务端。</li><li>服务端接收成功后，回传一个带有<code>SYN/ACK</code>标志的数据包传递确认信息，表示我收到了。</li><li>客户端再回传一个带有<code>ACK</code>标志的数据包，表示我知道了，握手结束。</li></ol><blockquote><p>场景脑补：有一天你看到个喜欢的人事，然后发了份简历过去 --&gt; 人事看到了就回复说已收到 --&gt; 你看到人事回消息了，就很开心的发了个🙈过去</p></blockquote><p>我总结下就是，客户端发连接请求，服务端收到就发送应答请求，客户端收到后，发送响应请求表示确认收到就连上了；</p><p>而HTTPS还需要进行<strong>TLS握手</strong>，</p><ol><li>客户端发送一个当前客户端信息的请求；包含TLS版本、生成的随机数、支持的加密算法组合及客户端所支持的参数选项。</li><li>服务器发送响应请求；包含服务器证书和一些加密参数，像加密算法、压缩算法、生成的随机数等。</li><li>客户端验证服务器证书的有效性，合法的CA、是否过期、请求域名和证书域名是否匹配...</li><li>客户端在确认证书没问题之后，就会生成一个随机数（称为预主密钥），然后使用服务器公钥加密，并将其发送给服务器。</li><li>服务器收到密钥，并对预主密钥解密，生成会话密钥；如果是<strong>RSA加密</strong>，会用随机数（客户端随机数和服务端随机数）以及预主密钥生成；如果是<strong>Diffie-Hellman或ECDH加密</strong>，则是用客户端和服务端各自生成的随机数做交换计算得到中间值来生成会话密钥。</li></ol><p>继续总结下，就是客户端把自己信息发给服务器，服务器再根据这些信息返回匹配的内容及证书，客户端确认证书没问题，就生成个随机数发给服务器，服务器收到之后，就生成一个密钥，后续用这个密钥来当连接的校验凭证。</p><h2 id="_4-客户端发送请求-📚" tabindex="-1"><a class="header-anchor" href="#_4-客户端发送请求-📚"><span>4. 客户端发送请求 📚</span></a></h2><p>根据设置好的请求路径、类型、请求头参数发起一个数据请求，但是这里还有个细节就是缓存，</p><p>一般在没有禁止缓存的情况下，如果是get请求或者是静态资源请求，在请求的时候会先去访问本地是否存在缓存，如果存在就返回200或304，不存在才会向服务端发送请求。</p><p>缓存分为两种：</p><p><strong>强缓存</strong>，只要资源未过期直接读取本地资源并返回200，通过<code>Expires</code>和<code>Cache-Control:max-age=&lt;seconds&gt;</code>两个请求头来控制，为了更精确的控制（<code>max-age</code>参数为请求的相对时间、减少<code>max-age</code>值来手动刷新），<code>Cache-Control</code>的优先级比<code>Expires</code>更高。</p><p><strong>协商缓存</strong>，强缓存失效时，浏览器携带上一次请求返回的响应头中的缓存标记（如<code>ETag、Last-Modified</code>等）向服务器发起请求，查询缓存的资源是否有效；资源没更新，就返回304，通知浏览器读取本地缓存，否则返回新的内容；参数的优先级方面，<code>ETag</code>要高于<code>Last-Modified</code>，因为<code>ETag</code>有更高的唯一性，对比资源变化会更加精准。</p><h2 id="_5-服务器处理请求并将对应内容给客户端-📚" tabindex="-1"><a class="header-anchor" href="#_5-服务器处理请求并将对应内容给客户端-📚"><span>5. 服务器处理请求并将对应内容给客户端 📚</span></a></h2><p>这里没有什么逻辑，就是服务器根据接口参数返回相关内容及状态码。</p><h2 id="_6-断开连接-📚" tabindex="-1"><a class="header-anchor" href="#_6-断开连接-📚"><span>6. 断开连接 📚</span></a></h2><p>正常情况下的断开连接发生在请求完毕之后的一段时间，可以分为请求完成之后的默认关闭、服务器主动关闭（设置<code>Connection:close</code>）及客户端主动关闭，这里就只说默认关闭，</p><p>现在大部分是http1.1及http2版本，都默认持久连接，http1.1由<code>Connection:keep-alive</code>设置，http2本身就默认持久连接，</p><p>不管HTTP1.1还是HTTP2都是一般情况下都是客户端通过主动发送关闭标记来触发，通过四次挥手来完全关闭连接，</p><ol><li><strong>客户端发送关闭请求</strong>，客户端发送一个<code>FIN</code>，用来关闭客户端到服务器的数据传送，告诉服务器这已经处理完了，并且指定一个序列号。客户端进入<code>FIN_WAIT_1</code>状态。</li><li><strong>服务端收到请求并回复</strong>，服务器收到<code>FIN</code>后，发送一个<code>ACK</code>给客户端，确认序号为客户端的序列号值+1 ，表明已经收到客户端的报文了，此时服务器处于<code>CLOSE_WAIT</code>状态。</li><li><strong>服务端进入准备关闭阶段</strong>，服务器发送完数据之后，就会发送一个<code>FIN</code>，用来关闭服务器到客户端的数据传送，服务器进入<code>LAST_ACK</code>状态。</li><li><strong>两个端关闭连接</strong>，客户端收到<code>FIN</code>后，客户端进入<code>TIME_WAIT</code>状态，接着发送一个<code>ACK</code>给服务器，确认序号为收到序号+1 ，服务器收到确认后进入<code>CLOSED</code>状态。</li></ol><p>总结下，就是上面内容的黑色加粗文字字单独拎出来连成一句话，</p><blockquote><p>场景脑补： 有一天...</p><p>你提了个离职，</p><p>人事看到点了同意，并告诉你流程已经通过了，</p><p>又过了一会，人事准备好了离职单，送到了你办公桌，</p><p>你拿到之后，签好字就去送给了人事，</p><p>然后回到工位坐等下班走人，</p></blockquote><p>划<strong>重点</strong>，如果是<code>http</code>协议，其实不用到下面的内容就已经结束了，但是！！！</p><p>现在基本上都用上了<code>https</code>，这里还有一个细节，就是在进行<code>TCP</code>四次挥手之前，<code>https</code>还有一个<code>TLS</code>的关闭握手，</p><ol><li><strong>任意一端发起关闭</strong>，会发送一个<code>close_notify</code>握手消息来发起<code>TLS</code>会话的关闭，发送完毕之后发送方的写通道立即关闭，它不会再发送任何应用数据，但它可以继续接收发送方消息，直到它接收到对方的<code>close_notify</code>消息。</li><li><strong>接收方响应关闭</strong>：接收方在收到<code>close_notify</code>消息后，也会发送一个<code>close_notify</code>消息给发送方表示同意关闭。</li><li><strong>断开连接</strong>：一旦双方各自发送了<code>close_notify</code>消息，<code>TLS</code>记录协议就会停止使用之前的加密状态进行加密，并且双方都可以释放<code>TLS</code>连接的资源。</li></ol><p>这里的发送方也不一定就是客户端，也有可能是服务端发起关闭</p><h2 id="_7-客户端接收文件-解析html-📚" tabindex="-1"><a class="header-anchor" href="#_7-客户端接收文件-解析html-📚"><span>7. 客户端接收文件，解析HTML 📚</span></a></h2><p>客户端拿到<code>html</code>文件之后，就开始从上到下的逐行解析生成<code>DOM</code>树，解析<code>CSS</code>文件生成<code>CSSOM</code>树，最后由<code>DOM</code>树和<code>CSS</code>树合并为渲染树，</p><p>需要注意的是，在整个解析过程，除了<code>script</code>脚本会阻塞页面解析（可以使用<code>async</code>或者<code>defer</code>），遇到外部<code>CSS</code>文件时，在等待下载的过程同样是会阻塞页面的（可以加载个第三方的<code>CSS</code>文件链接复现，可通过<code>JS</code>异步加载<code>CSS</code>文件解决），</p><h2 id="_8-页面渲染-📚" tabindex="-1"><a class="header-anchor" href="#_8-页面渲染-📚"><span>8. 页面渲染 📚</span></a></h2><p><strong>回流</strong>，首先浏览器遍历渲染树，计算每个可见节点在屏幕上的位置和大小等几何属性；在这个过程中，因为节点几何属性的变化，又需要对受影响节点重新计算布局，同时回流的时候必定会触发重绘，所以频繁回流会占用大量的资源来进行布局计算。</p><p><strong>重绘</strong>，在布局完成之后，按照渲染树的顺序，逐个绘制节点，包括颜色、边框、渲染背景、文字、图像等内容。</p><h2 id="分割线🌟🌟🌟" tabindex="-1"><a class="header-anchor" href="#分割线🌟🌟🌟"><span>分割线🌟🌟🌟</span></a></h2><h2 id="写在最后" tabindex="-1"><a class="header-anchor" href="#写在最后"><span>写在最后</span></a></h2>',44),n={href:"https://juejin.cn/post/7298329919389564943",target:"_blank",rel:"noopener noreferrer"},i={},t=(0,l(6262).A)(i,[["render",function(e,o){const l=(0,c.g2)("ExternalLinkIcon");return(0,c.uX)(),(0,c.CE)("div",null,[d,(0,c.Lk)("p",null,[(0,c.eW)("在经过了上面这些流程，浏览器就完成了从输入URL到显示网页内容的全过程，在整个过程中，还会有很多页面加载性能的优化可以去做，感兴趣的可以看看这个"),(0,c.Lk)("a",n,[(0,c.eW)("写给自己的前端性能优化"),(0,c.bF)(l)]),(0,c.eW)("。")])])}]]),a=JSON.parse('{"path":"/blogs/article/9.shuruyigeURL，huichezhihoudaoyemianxuanrandenaxieshi.html","title":"输入一个URL，回车之后到页面渲染的那些事","lang":"en-US","frontmatter":{"title":"输入一个URL，回车之后到页面渲染的那些事","date":"2024-04-26T00:00:00.000Z","categories":["article"],"tags":["浏览器"]},"headers":[{"level":2,"title":"1. 地址解析与URL分析 📚","slug":"_1-地址解析与url分析-📚","link":"#_1-地址解析与url分析-📚","children":[]},{"level":2,"title":"2. DNS解析📚","slug":"_2-dns解析📚","link":"#_2-dns解析📚","children":[]},{"level":2,"title":"3. 和服务器建立连接 📚","slug":"_3-和服务器建立连接-📚","link":"#_3-和服务器建立连接-📚","children":[]},{"level":2,"title":"4. 客户端发送请求 📚","slug":"_4-客户端发送请求-📚","link":"#_4-客户端发送请求-📚","children":[]},{"level":2,"title":"5. 服务器处理请求并将对应内容给客户端 📚","slug":"_5-服务器处理请求并将对应内容给客户端-📚","link":"#_5-服务器处理请求并将对应内容给客户端-📚","children":[]},{"level":2,"title":"6. 断开连接 📚","slug":"_6-断开连接-📚","link":"#_6-断开连接-📚","children":[]},{"level":2,"title":"7. 客户端接收文件，解析HTML 📚","slug":"_7-客户端接收文件-解析html-📚","link":"#_7-客户端接收文件-解析html-📚","children":[]},{"level":2,"title":"8. 页面渲染 📚","slug":"_8-页面渲染-📚","link":"#_8-页面渲染-📚","children":[]},{"level":2,"title":"分割线🌟🌟🌟","slug":"分割线🌟🌟🌟","link":"#分割线🌟🌟🌟","children":[]},{"level":2,"title":"写在最后","slug":"写在最后","link":"#写在最后","children":[]}],"git":{"createdTime":1737108179000,"updatedTime":1737108179000,"contributors":[{"name":"稀饭","email":"lixifan@ane56.com","commits":1}]},"filePathRelative":"blogs/article/9.输入一个URL，回车之后到页面渲染的那些事.md"}')}}]);